package (Keyword)
main (Identifier)
; (Operator)
import (Keyword)
fmt (Literal)
; (Operator)
import (Keyword)
math (Literal)
; (Operator)
func (Keyword)
main (Identifier)
( (Operator)
) (Operator)
{ (Operator)
var (Keyword)
a (Identifier)
, (Operator)
t (Identifier)
, (Operator)
j (Identifier)
= (Operator)
10 (Number)
, (Operator)
- (Operator)
2 (Number)
* (Operator)
4 (Number)
+ (Operator)
9 (Number)
, (Operator)
5 (Number)
; (Operator)
alpha (Identifier)
, (Operator)
beta (Identifier)
, (Operator)
gamma (Identifier)
:= (Operator)
( (Operator)
- (Operator)
400 (Number)
+ (Operator)
1000 (Number)
) (Operator)
/ (Operator)
32 (Number)
, (Operator)
8400 (Number)
, (Operator)
- (Operator)
7 (Number)
/ (Operator)
3 (Number)
; (Operator)
var (Keyword)
b (Identifier)
= (Operator)
math (Identifier)
. (Operator)
sqrt (Identifier)
( (Operator)
25 (Number)
) (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
alpha (Identifier)
, (Operator)
beta (Identifier)
, (Operator)
gamma (Identifier)
) (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
I can print like anything! (Literal)
, (Operator)
1 (Number)
, (Operator)
2 (Number)
, (Operator)
3 (Number)
+ (Operator)
( (Operator)
8 (Number)
/ (Operator)
2 (Number)
) (Operator)
* (Operator)
4 (Number)
- (Operator)
4 (Number)
, (Operator)
gamma (Identifier)
) (Operator)
; (Operator)
for (Keyword)
i (Identifier)
:= (Operator)
0 (Number)
; (Operator)
i (Identifier)
< (Operator)
a (Identifier)
; (Operator)
i (Identifier)
++ (Operator)
{ (Operator)
var (Keyword)
alpha (Identifier)
= (Operator)
10 (Number)
; (Operator)
if (Keyword)
c (Identifier)
:= (Operator)
math (Identifier)
. (Operator)
sqrt (Identifier)
( (Operator)
3 (Number)
* (Operator)
3 (Number)
+ (Operator)
4 (Number)
* (Operator)
4 (Number)
) (Operator)
; (Operator)
b (Identifier)
== (Operator)
5 (Number)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
It is b: (Literal)
, (Operator)
b (Identifier)
) (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
And c: (Literal)
, (Operator)
c (Identifier)
) (Operator)
; (Operator)
b (Identifier)
= (Operator)
8 (Number)
; (Operator)
} (Operator)
else (Keyword)
if (Keyword)
c (Identifier)
= (Operator)
3 (Number)
; (Operator)
a (Identifier)
< (Operator)
5 (Number)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
It will not be printed (Literal)
) (Operator)
; (Operator)
} (Operator)
else (Keyword)
if (Keyword)
gamma (Identifier)
< (Operator)
0 (Number)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
It will be printed eventually, gamma: (Literal)
, (Operator)
gamma (Identifier)
) (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
And c: (Literal)
, (Operator)
c (Identifier)
) (Operator)
; (Operator)
break (Keyword)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
for (Keyword)
{ (Operator)
k1 (Identifier)
:= (Operator)
0 (Number)
break (Keyword)
; (Operator)
for (Keyword)
{ (Operator)
k2 (Identifier)
:= (Operator)
0 (Number)
break (Keyword)
; (Operator)
for (Keyword)
{ (Operator)
k3 (Identifier)
:= (Operator)
0 (Number)
break (Keyword)
; (Operator)
for (Keyword)
{ (Operator)
k4 (Identifier)
:= (Operator)
0 (Number)
break (Keyword)
; (Operator)
for (Keyword)
{ (Operator)
k5 (Identifier)
:= (Operator)
0 (Number)
break (Keyword)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
