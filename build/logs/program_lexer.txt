package (Keyword)
main (Identifier)
; (Operator)
import (Keyword)
fmt (Literal)
; (Operator)
import (Keyword)
math (Literal)
; (Operator)
func (Keyword)
main (Identifier)
( (Operator)
) (Operator)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
I am a simple program, let me introduce myself: (Literal)
) (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
I can do for: (Literal)
) (Operator)
; (Operator)
for (Keyword)
i (Identifier)
:= (Operator)
0 (Number)
; (Operator)
i (Identifier)
< (Operator)
10 (Number)
; (Operator)
i (Identifier)
++ (Operator)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
i is  (Literal)
, (Operator)
i (Identifier)
) (Operator)
; (Operator)
} (Operator)
; (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
I can do if: (Literal)
) (Operator)
; (Operator)
if (Keyword)
hyp (Identifier)
:= (Operator)
5. (Number)
; (Operator)
hyp (Identifier)
== (Operator)
math (Identifier)
. (Operator)
Sqrt (Identifier)
( (Operator)
3 (Number)
* (Operator)
3 (Number)
+ (Operator)
4 (Number)
* (Operator)
4 (Number)
) (Operator)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
Hypotenuse is indeed 5 (Literal)
) (Operator)
; (Operator)
} (Operator)
else (Keyword)
{ (Operator)
fmt (Identifier)
. (Operator)
Println (Identifier)
( (Operator)
You just broke Euclidean math, good job! (Literal)
) (Operator)
; (Operator)
} (Operator)
; (Operator)
} (Operator)
; (Operator)
